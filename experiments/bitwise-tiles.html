<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="generator" content="Observable Framework v1.13.0">
<title>Bit operations for creative coding | Tronicart</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" crossorigin>
<link rel="preload" as="style" href="../_observablehq/theme-parchment.d89d0dee.css">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" crossorigin>
<link rel="stylesheet" type="text/css" href="../_observablehq/theme-parchment.d89d0dee.css">
<link rel="modulepreload" href="../_observablehq/client.24f05b63.js">
<link rel="modulepreload" href="../_observablehq/runtime.f168f711.js">
<link rel="modulepreload" href="../_observablehq/stdlib.0e911bb9.js">
<link rel="modulepreload" href="https://early.webawesome.com/webawesome@3.0.0-alpha.8/dist/webawesome.loader.js">
<link rel="modulepreload" href="../_import/components/sketch.96f782c4.js">
<link rel="modulepreload" href="../_npm/lodash@4.17.21/0fff0f78.js">
<link rel="modulepreload" href="../_import/components/p5.08228e06.js">
<link rel="modulepreload" href="../_import/lib/helpers.23012005.js">
<link rel="modulepreload" href="../_import/lib/dom.46cf68a8.js">
<link rel="modulepreload" href="../_node/p5@1.11.2/index.8e5b333a.js">

<meta name="description" content="Creative coding and art">
<meta name="keywords" content="creative, code, art, github">
<meta name="author" content="Patrick Rabier">

<meta property="og:title" content="Bit operations for creative coding">
<meta property="og:type" content="article">
<meta property="og:url" content="/experiments/bitwise-tiles">
<meta property="og:image" content="https://tronica.io/_file/data/images/og-thumb.png">
<meta name="twitter:card" content="Creative coding and art">
<meta name="twitter:site" content="@tronicapps">
<meta name="twitter:creator" content="@tronicapps">

<link rel="stylesheet" href="https://early.webawesome.com/webawesome@3.0.0-alpha.8/dist/styles/themes/default.css">
<script type="module" src="https://early.webawesome.com/webawesome@3.0.0-alpha.8/dist/webawesome.loader.js"></script>


<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-GCRE839L0Y"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-GCRE839L0Y');
</script>
  

<script type="module">

import {define} from "../_observablehq/client.24f05b63.js";

define({id: "20bbc4ef", outputs: ["draw","sketch","_"], body: async () => {
const [{draw, sketch}, {default: _}] = await Promise.all([import("../_import/components/sketch.96f782c4.js"), import("../_npm/lodash@4.17.21/0fff0f78.js")]);

return {draw,sketch,_};
}});

define({id: "5dde9801", outputs: ["CELL_SIZE","MARGIN","TILE_SIZE","HALF_TILE","SEPIA","TERTIARY","LIGHT","WHITE","DARK","STRIPES","CIRCLES","IMAGE"], body: () => {
const CELL_SIZE = 50
const MARGIN = 5
const TILE_SIZE = CELL_SIZE - MARGIN * 2
const HALF_TILE = TILE_SIZE / 2
const SEPIA = "#f2e9e4"
const TERTIARY = "#00b4d8"
const LIGHT = SEPIA
const WHITE = "#ffffff"
const DARK = "#000000"
const STRIPES = 1
const CIRCLES = 2
const IMAGE =
  "https://images.unsplash.com/photo-1584635240092-d87d74854f68?q=80&w=2787&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D"
return {CELL_SIZE,MARGIN,TILE_SIZE,HALF_TILE,SEPIA,TERTIARY,LIGHT,WHITE,DARK,STRIPES,CIRCLES,IMAGE};
}});

define({id: "c64f63a6", outputs: ["resetStyles"], body: () => {
function resetStyles(p5) {
  p5.noFill()
  p5.noStroke()
  p5.strokeWeight(3)
}
return {resetStyles};
}});

define({id: "e3c9e87c", inputs: ["_","resetStyles","CIRCLES","STRIPES","DARK","LIGHT","TERTIARY"], outputs: ["createTempGfx","drawTile"], body: (_,resetStyles,CIRCLES,STRIPES,DARK,LIGHT,TERTIARY) => {
const createTempGfx = _.memoize((size, p5) => p5.createGraphics(size, size))

/**
 * Draws a tile with specific patterns and colors based on a given type.
 *
 * @param {p5} p5 - The p5.js instance to use for drawing.
 * @param {number} x - The x-coordinate where the tile should be drawn.
 * @param {number} y - The y-coordinate where the tile should be drawn.
 * @param {number} type - The byte value that determines the properties of the tile.
 */
function drawTile(p5, x, y, type, size) {
  const gfx = createTempGfx(size, p5)

  resetStyles(gfx)

  const show = type === 8

  type = 255 - (type % 256)
  const variations = type & 0b111
  const striped = (type & 0b1000) >> 3 == 0
  const stripeType = (type & 0b10000) >> 4 === 1 ? CIRCLES : STRIPES
  const border = (type & 0b100000) >> 5
  const useTertiary = (type & 0b1000000) >> 6
  const inverted = (type & 0b10000000) >> 7

  const bgColor = inverted ? DARK : LIGHT
  const fgColor = useTertiary ? TERTIARY : inverted ? LIGHT : DARK

  gfx.push()
  gfx.clear()

  gfx.background(bgColor)

  gfx.stroke(fgColor)

  if (striped) {
    gfx.push()
    if (stripeType === STRIPES) {
      const weight = 3
      gfx.rectMode(p5.CENTER)
      gfx.translate(size / 2, size / 2)
      gfx.rotate((p5.HALF_PI / 2) * variations)
      gfx.strokeWeight(weight)
      const left = -size + weight
      const right = size - weight
      const dist = p5.abs(left - right)
      const step = dist / 8
      for (let i = left; i < right; i += step) {
        gfx.line(i, -size, i, size)
      }
    } else {
      const { x, y } = [
        { x: 0, y: 1 },
        { x: 1, y: 0 },
        { x: 0, y: -1 },
        { x: -1, y: 0 },
        { x: 0.5, y: 0 },
        { x: 0, y: 0.5 },
        { x: 1, y: 0.5 },
        { x: 0.5, y: 1 },
      ][variations % 8]

      gfx.fill(fgColor)
      gfx.circle(x * size, y * size, size / 2)
      gfx.noFill()
      gfx.circle(x * size, y * size, size)
    }
    gfx.pop()
  }

  gfx.noFill()
  gfx.strokeWeight(border ? 7 : 0)
  gfx.rect(0, 0, size, size)

  gfx.pop()

  p5.image(gfx, x, y, size, size)
}
return {createTempGfx,drawTile};
}});

define({id: "fff1d172", inputs: ["draw","drawTile","display"], body: async (draw,drawTile,display) => {
display(await(
draw(750, 860, (p5) => {
  p5.background(255)
  const cellSize = 50
  const margin = 5
  const tileSize = cellSize - margin * 2
  for (let i = 0; i <= 255; i++) {
    const x = ((i - 1) % 15) * cellSize
    const y = Math.floor((i - 1) / 15) * cellSize
    drawTile(p5, x + margin, y + margin, i, tileSize)
    p5.fill(100)
    p5.noStroke()
    p5.textAlign(p5.CENTER, p5.CENTER)
    p5.textSize(8)
    p5.text(i.toString(), x + cellSize / 2, y + cellSize)
  }
})
))
}});

</script>
</head>
<body>
<input id="observablehq-sidebar-toggle" type="checkbox" title="Toggle sidebar">
<label id="observablehq-sidebar-backdrop" for="observablehq-sidebar-toggle"></label>
<nav id="observablehq-sidebar">
  <ol>
    <label id="observablehq-sidebar-close" for="observablehq-sidebar-toggle"></label>
    <li class="observablehq-link"><a href="../">Tronicart</a></li>
  </ol>
  <div id="observablehq-search"><input type="search" placeholder="Search"></div>
  <div id="observablehq-search-results"></div>
  <script>{const o=document.querySelector("#observablehq-search");o.setAttribute("data-shortcut",`${/Mac|iPhone/.test(navigator.platform)?"\u2318":"Alt-"}K`);const t=o.querySelector("input"),r=()=>import("../_observablehq/search.a1212c59.js");t.addEventListener("focus",r,{once:!0}),t.addEventListener("keydown",r,{once:!0});const c=document.querySelector("#observablehq-sidebar-toggle");addEventListener("keydown",e=>{(e.code==="KeyK"&&e.metaKey&&!e.altKey&&!e.ctrlKey||e.key==="/"&&!e.metaKey&&!e.altKey&&!e.ctrlKey&&e.target===document.body)&&(c.checked?t.focus():(c.click(),t.focus(),c.click()),t.select(),e.preventDefault())});}</script>
  <section class="observablehq-section-active">
    <summary>Experiments</summary>
    <ol>
    <li class="observablehq-link"><a href="./raytracing-wasm">Raytracing with Go and Wasm</a></li>
    <li class="observablehq-link"><a href="./three-body-problem">Three body problem</a></li>
    <li class="observablehq-link"><a href="./hand-drawn">Hand-drawn lines</a></li>
    <li class="observablehq-link observablehq-link-active"><a href="./bitwise-tiles">Bitwise creativity</a></li>
    </ol>
  </section>
  <details open>
    <summary>Creative algorithms</summary>
    <ol>
    <li class="observablehq-link"><a href="../algorithms/composition">Composable sketches</a></li>
    <li class="observablehq-link"><a href="../algorithms/differential-growth-basics">Differential growth</a></li>
    <li class="observablehq-link"><a href="../algorithms/orbital-mechanics">Orbital mechanics</a></li>
    </ol>
  </details>
  <details>
    <summary>Articles</summary>
    <ol>
    <li class="observablehq-link"><a href="../articles/state-management">An outlook on state management</a></li>
    <li class="observablehq-link"><a href="../articles/custom-react-hook">Custom React API hook</a></li>
    <li class="observablehq-link"><a href="../articles/observable-seo">Observable SEO</a></li>
    </ol>
  </details>
  <details>
    <summary>Playgrounds</summary>
    <ol>
    <li class="observablehq-link"><a href="../playgrounds/falling-sand">Falling sand</a></li>
    <li class="observablehq-link"><a href="../playgrounds/triangles">Triangles</a></li>
    <li class="observablehq-link"><a href="../playgrounds/hexmesh/">Hexmesh</a></li>
    </ol>
  </details>
  <ol>
    <li class="observablehq-link"><a href="https://github.com/patrixr" target="_blank"><span>Github</span></a></li>
    <li class="observablehq-link"><a href="https://x.com/tronicapps" target="_blank"><span>Twitter</span></a></li>
    <li class="observablehq-link"><a href="https://objkt.com/users/tz1dQEFRNPdx2TXqfcprr1XCKdcUfir9geTP" target="_blank"><span>NFTs</span></a></li>
  </ol>
</nav>
<script>{const e=document.querySelector("#observablehq-sidebar"),o=document.querySelector("#observablehq-sidebar-toggle"),r=sessionStorage.getItem("observablehq-sidebar");r?o.checked=r==="true":o.indeterminate=!0;for(const t of document.querySelectorAll("#observablehq-sidebar summary")){const s=t.parentElement;switch(sessionStorage.getItem(`observablehq-sidebar:${t.textContent}`)){case"true":s.open=!0;break;case"false":s.classList.contains("observablehq-section-active")||(s.open=!1);break}}addEventListener("beforeunload",()=>sessionStorage.setItem("observablehq-sidebar-scrolly",`${e.scrollTop}`));const a=sessionStorage.getItem("observablehq-sidebar-scrolly");a!=null&&(e.style.cssText="overflow: hidden;",e.scrollTop=+a,e.style.cssText="");}</script>
<div id="observablehq-center">
<aside id="observablehq-toc" data-selector="h1:not(:first-of-type)[id], h2:first-child[id], :not(h1) + h2[id]">
<nav>
<div>Contents</div>
<ol>
<li class="observablehq-secondary-link"><a href="#extracting-properties">Extracting properties</a></li>
<li class="observablehq-secondary-link"><a href="#rendering-tiles-based-on-properties">Rendering tiles based on properties</a></li>
<li class="observablehq-secondary-link"><a href="#observations">Observations</a></li>
</ol>
</nav>
</aside>
<main id="observablehq-main" class="observablehq">
<h1 id="bit-operations-for-creative-coding" tabindex="-1"><a class="observablehq-header-anchor" href="#bit-operations-for-creative-coding">Bit operations for creative coding</a></h1>
<p>I'm investigating the idea of converting a byte value to a tile. The idea is to use the properties of the byte to determine the properties of the tile. This could possibly be used with a grayscale image to create a mosaic of tiles.</p>
<p>Before I figure out an artwork to create with this concept, I want to experiment with the idea. I'll start by creating a simple grid of tiles, each tile representing a byte value.</p>
<p>Leveraging a bitmask to extract the properties of the byte, I could then use these properties to draw the tile. Here's a set or <strong>arbitrary rules</strong> I'll use to determine the properties of the tile based on the binary representation of the byte:</p>
<div style="background: #AAAAAA; width: 500px; margin: 30px 0px;">
<img src="../_file/data/images/byte-tiles.706933d1.png">
</div>
<div class="observablehq observablehq--block"><!--:20bbc4ef:--></div>
<h2 id="extracting-properties" tabindex="-1"><a class="observablehq-header-anchor" href="#extracting-properties">Extracting properties</a></h2>
<p>Now that we have a set of rules to determine the properties of the tile, we need to extract these properties from the byte value. We can do this by using a bitmask to extract the bits that represent each property.</p>
<p>Example of extracting the properties from a byte value:</p>
<pre data-language="typescript"><code class="language-typescript"><span class="hljs-keyword">const</span> variations = <span class="hljs-keyword">type</span> &amp; <span class="hljs-number">0b111</span>
<span class="hljs-keyword">const</span> striped = (<span class="hljs-keyword">type</span> &amp; <span class="hljs-number">0b1000</span>) &gt;&gt; <span class="hljs-number">3</span>
<span class="hljs-keyword">const</span> stripeType = (<span class="hljs-keyword">type</span> &amp; <span class="hljs-number">0b10000</span>) &gt;&gt; <span class="hljs-number">4</span>
<span class="hljs-keyword">const</span> border = (<span class="hljs-keyword">type</span> &amp; <span class="hljs-number">0b100000</span>) &gt;&gt; <span class="hljs-number">5</span>
<span class="hljs-keyword">const</span> useTertiary = (<span class="hljs-keyword">type</span> &amp; <span class="hljs-number">0b1000000</span>) &gt;&gt; <span class="hljs-number">6</span>
<span class="hljs-keyword">const</span> inverted = (<span class="hljs-keyword">type</span> &amp; <span class="hljs-number">0b10000000</span>) &gt;&gt; <span class="hljs-number">7</span>
</code></pre>
<p>Some more advanced usages could include using the properties to determine the color of the tile, the shape of the tile, or the texture of the tile, etc</p>
<h2 id="rendering-tiles-based-on-properties" tabindex="-1"><a class="observablehq-header-anchor" href="#rendering-tiles-based-on-properties">Rendering tiles based on properties</a></h2>
<p>I want to be able to visualize the properties of the byte value by rendering a tile based on these properties. I'll start by creating a simple grid of tiles, each tile representing a byte value.</p>
<div class="observablehq observablehq--block"><!--:5dde9801:--></div>
<div class="observablehq observablehq--block"><!--:c64f63a6:--></div>
<div class="observablehq observablehq--block"><!--:e3c9e87c:--></div>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:fff1d172:--></div>
<h2 id="observations" tabindex="-1"><a class="observablehq-header-anchor" href="#observations">Observations</a></h2>
<p>As of now, it's hard to see the patterns in the tiles. I think it would be beneficial to add some more variation to the tiles to make them more visually distinct. I don't yet have a good use case for this technique, but I believe it could be useful for generating procedural textures or patterns.</p>
<p>In short, to be continued...</p>
</main>
<footer id="observablehq-footer">
<nav><a rel="prev" href="./hand-drawn"><span>Hand-drawn lines</span></a><a rel="next" href="../algorithms/composition"><span>Composable sketches</span></a></nav>
<div>Built with <a href="https://observablehq.com/" target="_blank" rel="noopener noreferrer">Observable</a> on <a title="2025-01-09T14:32:55">Jan 9, 2025</a>.</div>
</footer>
</div>
</body>
</html>
