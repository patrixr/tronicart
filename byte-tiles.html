<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="generator" content="Observable Framework v1.13.0">
<title>Bit operations for creative coding | Tronicart</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" crossorigin>
<link rel="preload" as="style" href="./_observablehq/theme-parchment.d89d0dee.css">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" crossorigin>
<link rel="stylesheet" type="text/css" href="./_observablehq/theme-parchment.d89d0dee.css">
<link rel="modulepreload" href="./_observablehq/client.b6605194.js">
<link rel="modulepreload" href="./_observablehq/runtime.9393ab6d.js">
<link rel="modulepreload" href="./_observablehq/stdlib.95bfbf7e.js">
<link rel="modulepreload" href="./_import/components/sketch.16785f60.js">
<link rel="modulepreload" href="./_npm/lodash@4.17.21/cbfa4f05.js">
<link rel="modulepreload" href="./_import/lib/helpers.23012005.js">
<link rel="modulepreload" href="./_import/lib/dom.46cf68a8.js">
<link rel="modulepreload" href="./_node/p5@1.11.2/index.1b9ecc21.js">
<script type="module">

import {define} from "./_observablehq/client.b6605194.js";

define({id: "506d0ce0", outputs: ["draw","sketch","_"], body: async () => {
const [{draw, sketch}, {default: _}] = await Promise.all([import("./_import/components/sketch.16785f60.js"), import("./_npm/lodash@4.17.21/cbfa4f05.js")]);

return {draw,sketch,_};
}});

define({id: "5dde9801", outputs: ["CELL_SIZE","MARGIN","TILE_SIZE","HALF_TILE","SEPIA","TERTIARY","LIGHT","WHITE","DARK","STRIPES","CIRCLES","IMAGE"], body: () => {
const CELL_SIZE = 50
const MARGIN = 5
const TILE_SIZE = CELL_SIZE - MARGIN * 2
const HALF_TILE = TILE_SIZE / 2
const SEPIA = "#f2e9e4"
const TERTIARY = "#00b4d8"
const LIGHT = SEPIA
const WHITE = "#ffffff"
const DARK = "#000000"
const STRIPES = 1
const CIRCLES = 2
const IMAGE =
  "https://images.unsplash.com/photo-1584635240092-d87d74854f68?q=80&w=2787&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D"
return {CELL_SIZE,MARGIN,TILE_SIZE,HALF_TILE,SEPIA,TERTIARY,LIGHT,WHITE,DARK,STRIPES,CIRCLES,IMAGE};
}});

define({id: "c64f63a6", outputs: ["resetStyles"], body: () => {
function resetStyles(p5) {
  p5.noFill()
  p5.noStroke()
  p5.strokeWeight(3)
}
return {resetStyles};
}});

define({id: "e3c9e87c", inputs: ["_","resetStyles","CIRCLES","STRIPES","DARK","LIGHT","TERTIARY"], outputs: ["createTempGfx","drawTile"], body: (_,resetStyles,CIRCLES,STRIPES,DARK,LIGHT,TERTIARY) => {
const createTempGfx = _.memoize((size, p5) => p5.createGraphics(size, size))

/**
 * Draws a tile with specific patterns and colors based on a given type.
 *
 * @param {p5} p5 - The p5.js instance to use for drawing.
 * @param {number} x - The x-coordinate where the tile should be drawn.
 * @param {number} y - The y-coordinate where the tile should be drawn.
 * @param {number} type - The byte value that determines the properties of the tile.
 */
function drawTile(p5, x, y, type, size) {
  const gfx = createTempGfx(size, p5)

  resetStyles(gfx)

  const show = type === 8

  type = 255 - (type % 256)
  const variations = type & 0b111
  const striped = (type & 0b1000) >> 3 == 0
  const stripeType = (type & 0b10000) >> 4 === 1 ? CIRCLES : STRIPES
  const border = (type & 0b100000) >> 5
  const useTertiary = (type & 0b1000000) >> 6
  const inverted = (type & 0b10000000) >> 7

  const bgColor = inverted ? DARK : LIGHT
  const fgColor = useTertiary ? TERTIARY : inverted ? LIGHT : DARK

  gfx.push()
  gfx.clear()

  gfx.background(bgColor)

  gfx.stroke(fgColor)

  if (striped) {
    gfx.push()
    if (stripeType === STRIPES) {
      const weight = 3
      gfx.rectMode(p5.CENTER)
      gfx.translate(size / 2, size / 2)
      gfx.rotate((p5.HALF_PI / 2) * variations)
      gfx.strokeWeight(weight)
      const left = -size + weight
      const right = size - weight
      const dist = p5.abs(left - right)
      const step = dist / 8
      for (let i = left; i < right; i += step) {
        gfx.line(i, -size, i, size)
      }
    } else {
      const { x, y } = [
        { x: 0, y: 1 },
        { x: 1, y: 0 },
        { x: 0, y: -1 },
        { x: -1, y: 0 },
        { x: 0.5, y: 0 },
        { x: 0, y: 0.5 },
        { x: 1, y: 0.5 },
        { x: 0.5, y: 1 },
      ][variations % 8]

      gfx.fill(fgColor)
      gfx.circle(x * size, y * size, size / 2)
      gfx.noFill()
      gfx.circle(x * size, y * size, size)
    }
    gfx.pop()
  }

  gfx.noFill()
  gfx.strokeWeight(border ? 7 : 0)
  gfx.rect(0, 0, size, size)

  gfx.pop()

  p5.image(gfx, x, y, size, size)
}
return {createTempGfx,drawTile};
}});

define({id: "fff1d172", inputs: ["draw","drawTile","display"], body: async (draw,drawTile,display) => {
display(await(
draw(750, 860, (p5) => {
  p5.background(255)
  const cellSize = 50
  const margin = 5
  const tileSize = cellSize - margin * 2
  for (let i = 0; i <= 255; i++) {
    const x = ((i - 1) % 15) * cellSize
    const y = Math.floor((i - 1) / 15) * cellSize
    drawTile(p5, x + margin, y + margin, i, tileSize)
    p5.fill(100)
    p5.noStroke()
    p5.textAlign(p5.CENTER, p5.CENTER)
    p5.textSize(8)
    p5.text(i.toString(), x + cellSize / 2, y + cellSize)
  }
})
))
}});

</script>
</head>
<body>
<input id="observablehq-sidebar-toggle" type="checkbox" title="Toggle sidebar">
<label id="observablehq-sidebar-backdrop" for="observablehq-sidebar-toggle"></label>
<nav id="observablehq-sidebar">
  <ol>
    <label id="observablehq-sidebar-close" for="observablehq-sidebar-toggle"></label>
    <li class="observablehq-link"><a href="./">Tronicart</a></li>
  </ol>
  <div id="observablehq-search"><input type="search" placeholder="Search"></div>
  <div id="observablehq-search-results"></div>
  <script>{const o=document.querySelector("#observablehq-search");o.setAttribute("data-shortcut",`${/Mac|iPhone/.test(navigator.platform)?"\u2318":"Alt-"}K`);const t=o.querySelector("input"),r=()=>import("./_observablehq/search.176e2af2.js");t.addEventListener("focus",r,{once:!0}),t.addEventListener("keydown",r,{once:!0});const c=document.querySelector("#observablehq-sidebar-toggle");addEventListener("keydown",e=>{(e.code==="KeyK"&&e.metaKey&&!e.altKey&&!e.ctrlKey||e.key==="/"&&!e.metaKey&&!e.altKey&&!e.ctrlKey&&e.target===document.body)&&(c.checked?t.focus():(c.click(),t.focus(),c.click()),t.select(),e.preventDefault())});}</script>
  <ol>
    <li class="observablehq-link observablehq-link-active"><a href="./byte-tiles">Bit operations for creative coding</a></li>
    <li class="observablehq-link"><a href="./composition">Composable Sketches</a></li>
    <li class="observablehq-link"><a href="./differential-growth-basics">Differential Growth Basics</a></li>
    <li class="observablehq-link"><a href="./falling-sand">Falling Sand</a></li>
    <li class="observablehq-link"><a href="./hand-drawn">Hand drawn lines</a></li>
    <li class="observablehq-link"><a href="./orbital-mechanics">Orbital Mechanics</a></li>
    <li class="observablehq-link"><a href="./raytracing-wasm">Raytracing using Go and WebAssembly</a></li>
    <li class="observablehq-link"><a href="./three-body-problem">Three Body Problem</a></li>
    <li class="observablehq-link"><a href="./triangles">Triangles</a></li>
  </ol>
</nav>
<script>{const e=document.querySelector("#observablehq-sidebar"),t=document.querySelector("#observablehq-sidebar-toggle"),r=sessionStorage.getItem("observablehq-sidebar");r?t.checked=r==="true":t.indeterminate=!0;for(const o of document.querySelectorAll("#observablehq-sidebar summary")){const s=o.parentElement;switch(sessionStorage.getItem(`observablehq-sidebar:${o.textContent}`)){case"true":s.open=!0;break;case"false":s.classList.contains("observablehq-section-active")||(s.open=!1);break}}addEventListener("beforeunload",()=>sessionStorage.setItem("observablehq-sidebar-scrolly",`${e.scrollTop}`));const a=sessionStorage.getItem("observablehq-sidebar-scrolly");a!=null&&(e.style.cssText="overflow: hidden;",e.scrollTop=+a,e.style.cssText="");}</script>
<div id="observablehq-center">
<aside id="observablehq-toc" data-selector="h1:not(:first-of-type)[id], h2:first-child[id], :not(h1) + h2[id]">
<nav>
<div>Contents</div>
<ol>
<li class="observablehq-secondary-link"><a href="#extracting-properties">Extracting properties</a></li>
<li class="observablehq-secondary-link"><a href="#rendering-tiles-based-on-properties">Rendering tiles based on properties</a></li>
<li class="observablehq-secondary-link"><a href="#observations">Observations</a></li>
</ol>
</nav>
</aside>
<main id="observablehq-main" class="observablehq">
<h1 id="bit-operations-for-creative-coding" tabindex="-1"><a class="observablehq-header-anchor" href="#bit-operations-for-creative-coding">Bit operations for creative coding</a></h1>
<p>I'm investigating the idea of converting a byte value to a tile. The idea is to use the properties of the byte to determine the properties of the tile. This could possibly be used with a grayscale image to create a mosaic of tiles.</p>
<p>Before I figure out an artwork to create with this concept, I want to experiment with the idea. I'll start by creating a simple grid of tiles, each tile representing a byte value.</p>
<p>Leveraging a bitmask to extract the properties of the byte, I could then use these properties to draw the tile. Here's a set or <strong>arbitrary rules</strong> I'll use to determine the properties of the tile based on the binary representation of the byte:</p>
<div style="background: #AAAAAA; width: 500px; margin: 30px 0px;">
<img src="./_file/data/images/byte-tiles.706933d1.png">
</div>
<div class="observablehq observablehq--block"><!--:506d0ce0:--></div>
<h2 id="extracting-properties" tabindex="-1"><a class="observablehq-header-anchor" href="#extracting-properties">Extracting properties</a></h2>
<p>Now that we have a set of rules to determine the properties of the tile, we need to extract these properties from the byte value. We can do this by using a bitmask to extract the bits that represent each property.</p>
<p>Example of extracting the properties from a byte value:</p>
<pre data-language="typescript"><code class="language-typescript"><span class="hljs-keyword">const</span> variations = <span class="hljs-keyword">type</span> &amp; <span class="hljs-number">0b111</span>
<span class="hljs-keyword">const</span> striped = (<span class="hljs-keyword">type</span> &amp; <span class="hljs-number">0b1000</span>) &gt;&gt; <span class="hljs-number">3</span>
<span class="hljs-keyword">const</span> stripeType = (<span class="hljs-keyword">type</span> &amp; <span class="hljs-number">0b10000</span>) &gt;&gt; <span class="hljs-number">4</span>
<span class="hljs-keyword">const</span> border = (<span class="hljs-keyword">type</span> &amp; <span class="hljs-number">0b100000</span>) &gt;&gt; <span class="hljs-number">5</span>
<span class="hljs-keyword">const</span> useTertiary = (<span class="hljs-keyword">type</span> &amp; <span class="hljs-number">0b1000000</span>) &gt;&gt; <span class="hljs-number">6</span>
<span class="hljs-keyword">const</span> inverted = (<span class="hljs-keyword">type</span> &amp; <span class="hljs-number">0b10000000</span>) &gt;&gt; <span class="hljs-number">7</span>
</code></pre>
<p>Some more advanced usages could include using the properties to determine the color of the tile, the shape of the tile, or the texture of the tile, etc</p>
<h2 id="rendering-tiles-based-on-properties" tabindex="-1"><a class="observablehq-header-anchor" href="#rendering-tiles-based-on-properties">Rendering tiles based on properties</a></h2>
<p>I want to be able to visualize the properties of the byte value by rendering a tile based on these properties. I'll start by creating a simple grid of tiles, each tile representing a byte value.</p>
<div class="observablehq observablehq--block"><!--:5dde9801:--></div>
<div class="observablehq observablehq--block"><!--:c64f63a6:--></div>
<div class="observablehq observablehq--block"><!--:e3c9e87c:--></div>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:fff1d172:--></div>
<h2 id="observations" tabindex="-1"><a class="observablehq-header-anchor" href="#observations">Observations</a></h2>
<p>As of now, it's hard to see the patterns in the tiles. I think it would be beneficial to add some more variation to the tiles to make them more visually distinct. I don't yet have a good use case for this technique, but I believe it could be useful for generating procedural textures or patterns.</p>
<p>In short, to be continued...</p>
</main>
<footer id="observablehq-footer">
<nav><a rel="prev" href="./"><span>Tronicart</span></a><a rel="next" href="./composition"><span>Composable Sketches</span></a></nav>
<div>Built with <a href="https://observablehq.com/" target="_blank" rel="noopener noreferrer">Observable</a> on <a title="2024-12-30T08:15:30">Dec 30, 2024</a>.</div>
</footer>
</div>
</body>
</html>
